\documentclass{report}

% Matemática
\usepackage{amsmath}    % símbolos matemáticos
\usepackage{amssymb}    % símbolos matemáticos
\usepackage{amsthm}     % teoremas
\usepackage{amsfonts}   % \mathbb
\usepackage{bm}         % bold math (https://ctan.org/pkg/bm)
\usepackage{abraces}    % \aunderbrace y \aoverbrace
\usepackage{mathtools}  % \mathclap

% Para hacer derivaciones y eso
% https://personal.utdallas.edu/~hamlen/trfrac.pdf
\usepackage{tfrac}

% Figuras
\usepackage{tikz}                   % gráficos
\usepackage{float}                  % [H]
\usepackage{xcolor}                 % colores https://es.overleaf.com/learn/latex/Using_colours_in_LaTeX

\usepackage{framed}     % textbars
% Texto
\usepackage[shortlabels]{enumitem}  % enumerate con letras

% Referencias
\usepackage[colorlinks=true]{hyperref}

% Programas
% https://tex.stackexchange.com/questions/116595/highlighting-haskell-listings-in-large-tex-document
% https://leportella.com/minted-vscode/
% https://tex.stackexchange.com/questions/367332/minted-error-undefined-control-sequence-pyg-with-texmaker
\usepackage[cache=false]{minted}     % código

\usetikzlibrary{arrows,positioning,automata,shadows,fit,shapes}

% Teoremas, corolarios, etc.
% https://www.overleaf.com/learn/latex/theorems_and_proofs
\theoremstyle{definition} % Para que no salga en italicas

\newtheorem{theorem}{Teorema}[chapter]
\newtheorem*{theorem*}{Teorema}

\newtheorem{lemma}{Lema}[chapter]
\newtheorem*{lemma*}{Lema}

\newtheorem{proposition}{Prop.}[chapter]
\newtheorem*{proposition*}{Prop}

\newtheorem{definition}{Def.}[chapter]
\newtheorem*{definition*}{Def}

\newtheorem{observation}{Obs.}[chapter]
\newtheorem*{observation*}{Obs}

\newtheorem{example}{Ejemplo}[chapter]
\newtheorem*{example*}{Ejemplo}

% https://tex.stackexchange.com/questions/118173/how-to-write-ceil-and-floor-in-latex
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% Comandos de PLP
%\newcommand{\sigmatsequence}{\overset{\rightarrow}{\sigma}}
%\newcommand{\tautsequence}{\overset{\rightarrow}{\tau}}

% Entornos
\newenvironment{nota}[1]
    {\begin{leftbar}\textbf{#1}}
    {\end{leftbar}}

% https://tex.stackexchange.com/questions/42619/x-mark-to-match-checkmark/42620
\usepackage{pifont} % http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}


% mate general
\newcommand{\eqdef}{\overset{\text{def}}{=}}
\newcommand{\aeq}{=_\alpha}
\newcommand{\naeq}{\neq_\alpha}

% calculo lambda
\newcommand{\lambdab}{\lambda^b}
\newcommand{\tfunc}[2]{#1 \to #2}
\newcommand{\ifte}[3]{\ if\ #1 \ then\ #2 \ else\ #3}
\newcommand{\abs}[3]{\lambda #1 : #2 . #3}
\newcommand{\app}[2]{#1 \ #2} % aplicación
\newcommand{\sust}[2]{#1 \{ #2 \}}
\newcommand{\sustOne}[3]{#1 \{ #2 \leftarrow #3 \}}

\newcommand{\tipa}[3]{#1 \rhd #2 : #3} % \vartriangleright
\newcommand{\tienetipo}[3]{#1 : #2 \in #3}
\newcommand{\Gtipa}[2]{\tipa{\Gamma}{#1}{#2}}
\newcommand{\GStipa}[2]{\tipa{\Gamma|\Sigma}{#1}{#2}}

\newcommand{\reduce}[2]{#1 \to #2}
\newcommand{\doesntReduce}[2]{#1 \not\to #2}
\newcommand{\reducesTo}[1]{\to_\text{(#1)}}

\newcommand{\reduceManyTo}{\twoheadrightarrow}
\newcommand{\reduceMany}[2]{#1 \reduceManyTo #2}

\newcommand{\deriv}[3]{\trfrac[(#1)]{#2}{#3}}
\newcommand{\derivok}[1]{\trfrac[]{\checkmark}{#1}}

% resolución
\newcommand{\resol}[2]{\frac{#1}{#2}}

% subtipado
\newcommand{\subt}[2]{#1 <: #2}

\newcommand{\ligada}[1]{\underbrace{#1}_{\text{ligada}}}
\newcommand{\libre}[1]{\underbrace{#1}_{\text{libre}}}

\author{Manuel Panichelli}
\title{Notas para final de PLP}

\begin{document}

\maketitle

\chapter{Paradigma funcional}

\section{Haskell}

\begin{definition}[Paradigma]
    Un \textbf{paradigma} es una forma de pensamiento.
\end{definition}

\begin{definition}[Lenguaje de programación]
    Un \textbf{lenguaje de programación} es el lenguaje que usamos para
    comunicar lo que queremos que haga una computadora.

    Usamos un lenguaje para describir los computos que lleva a cabo la
    computadora.
    
    Es \textbf{computacionalmente completo} si puede expresar todas las
    funciones computables. Hay DSLs (\textit{domain specific languages}) que no
    pueden expresar todo lo computable.
\end{definition}

\begin{definition}[Paradigma de lenguaje de programación]
    Lo entendemos como un \textit{estilo} de programación, que tiene que ver con
    los estilos de las soluciones. Está vinculado con lo que es para uno un
    modelo de cómputo.

    Lo que vemos antes de la materia es el imperativo: a partir de un estado
    inicial llegar a un estado final. Programamos con secuencias de
    instrucciones para cambiar el estado.
\end{definition}

\subsection{Programación funcional}

Definiciones:

\begin{itemize}
    \item \textbf{Programa y modelo de cómputo}: Programar es definir
    funciones, y ejecutar es evaluar expresiones.
    \item \textbf{Programa}: Es un conjunto de ecuaciones. Por ej.
    \texttt{doble x = x + x}
    \item \textbf{Expresiones}: El significado de una expresión es su valor
    (si es que está definido). El valor de una expresión depende solo del
    valor de sus sub-expresiones. Evaluar o reducir una expresion es obtener
    su valor (por ej. \texttt{doble 2 $\leadsto$ 4})
    No toda expresion denota un valor, por ejemplo \texttt{doble true}.
    \item \textbf{Tipos}: El universo de valores está particionado en
    colecciones denominadas \textit{tipos}, que tienen operaciones asociadas.
\end{itemize}

Haskell es \textbf{fuertemente tipado}. Toda expresion bien formada tiene un
tipo, que depende del tipo de sus subexpresiones. Si no puede asignarse un tipo
a una expresión, no se la considera bien formada.

\begin{minted}{haskell}
1           :: Int
'a'         :: Char
1.2         :: Float
True        :: Bool
[1, 2, 3]   :: [Int]
(1, True)   :: (Int, Bool)
succ        :: Int -> Int
\end{minted}

Definiciones de funciones:

\begin{minted}{haskell}
-- Definición
doble :: Int -> Int
doble x = x + x

-- Guardas
signo :: Int -> Bool
signo n | n >= 0    = True
        | otherwise = False

-- Definiciones locales
f (x, y) = g x + y
    where g z = z + 2

-- Expresiones lambda
\x -> x + 1
\end{minted}

\textbf{Tipos polimórficos}

\begin{minted}[]{haskell}
    id x = x
    id :: a -> a
    -- x es de tipo a, que eventualmente se va a instanciar a algún tipo
\end{minted}

\textbf{Clases de tipos}: Son como interfaces, que definen un conjunto de
operaciones.

\begin{minted}[]{haskell}
    maximo :: Ord a => a -> a -> a
    maximo x y | x > y = x
    maximo _ y = y
    -- Ord: (<), (<=), (>=), (>), max, min, compare
\end{minted}

\textbf{Tipos algebráicos}

\begin{minted}[]{haskell}
    data Figura = Circulo Float | Rectangulo Float Float
    deriving Eq -- deriva la igualdad nativa

    -- (Circulo 1) == (Circulo 1)
\end{minted}

Estas cosas nos permiten hacer funciones genéricas.

\textbf{Funciones de alto orden}: las funciones son first class citizens, se
pueden pasar como parámetro.

\subsection{Currificación}

Es un mecanismo que permite reemplazar argumentos estructurados por una
secuencia de argumentos "simples". Ventajas:

\begin{itemize}
    \item Evaluación parcial: \texttt{succ = suma 1}
    \item Evita escribir paréntesis (asumiendo que la aplicación asocia a
    izquierda). \texttt{suma 1 2 = ((suma 1) 2)}
\end{itemize}

\textbf{curry y uncurry}

En criollo: una equivalencia entre una func con muchos parametros (una tupla) y
una funcion equivalente que va tomando de a uno y devuelve funciones.

\begin{minted}[]{haskell}
    curry :: ((a, b) -> c) -> (a -> (b -> c))
    curry f a b = f (a, b)

    suma x y = x + y
    suma' :: (Int, Int) -> Int
    suma' (x, y) = x + y

    curry suma' 1 2 = suma' (1, 2)
    curry suma' :: (Int -> (Int -> Int))

    uncurry :: (a -> b -> c) -> ((a -> b) -> c)
    uncurry f (a, b) = f a b
\end{minted}

\subsection{Pattern matching}

Una forma copada de definir funciones. Es un mecanismo para comparar un valor
con un patrón. Si la comparación tiene éxito se puede deconstruir un valor en
sus partes.

\begin{minted}[]{haskell}
    data Figura = Circulo Float | Rectangulo Float Float

    area :: Figura -> Float
    area (Circulo radio) = pi * radio ^ 2
    area (Rectangulo l1 l2) = l1 * l2
\end{minted}

El patrón está formado por el constructor y las variables. Los casos se evalúan
en el orden en el que están escritos.

\begin{minted}[]{haskell}
    esCuadrado :: Figura -> Bool
    -- No vale esto?
    -- esCuadrado (Rectangulo x y) = (x == y)
    esCuadrado (Rectangulo x y) | (x==y) = True
    esCuadrado _ = False
\end{minted}

También se pueden definir funciones parciales (que no estén definidas para todo
el dominio).

\subsection{Tipos recursivos}
La definición de un tipo puede tener uno o más parámetros del tipo

\begin{minted}[]{haskell}
    data Natural = Zero | Succ Natural

    Zero :: Natural                     -- 0
    succ Zero :: Natural                -- 1
    succ (succ (succ Zero)) :: Natural  -- 2

    dameNumero :: Natural -> Int
    dameNumero Zero = 0
    dameNumero (Succ n) = dameNumero n + 1
\end{minted}

\subsection{Listas}

Tipo algebráico paramétrico recursivo con dos constructores:

\begin{minted}[]{haskell}
    [] :: [a]               -- lista vacia
    (:) :: a -> [a] -> [a]  -- constructor infijo

    -- Ejemplo
    --   1 : [2, 3] = [1, 2, 3]
\end{minted}

Pattern matching

\begin{minted}[]{haskell}
    vacia :: [a] -> Bool
    vacia [] = True
    vacia _ = False

    long :: [a] -> Int
    long [] = 0
    long x:xs = 1 + long xs
\end{minted}

\subsection{No terminación y orden de evaluación}

\begin{minted}[]{haskell}
    -- No terminación
    inf1 :: [Int]
    inf1 = 1 : inf1

    -- Evaluación no estricta
    const :: a -> b -> a
    const x y = x

    -- const 42 inf1 -> 42 (pero depende del mecanismo de reducción del
    -- lenguaje)
\end{minted}

\subsection{Evaluación lazy}

el modelo de cómputo de haskell es la \textbf{reducción}. Se reemplaza un
\textit{redex} por otro usando las ecuaciones orientadas. Un redex (reducible
expression) es una sub-expresión que no está en forma normal (irreducible).

Un redex debe ser una \textbf{instancia} del lado izquierdo de alguna ecuación y
será reemplazado por el lado derecho con las variables correspondientes ligadas.
El resto de la expresión no cambia.

Haskell hace esto hasta llegar a una forma normal, un valor irreducible.

\texttt{const x y = x}. \texttt{const x y} es un redex, y lo reduzco a
\texttt{x}.

Y cómo selecciono una redex? \textbf{Orden normal} (lazy). Se selecciona el
redex más externo para el que se pueda conocer que ecuación del programa
utilizar. En general, primero las funciones más externas y luego los argumentos,
solo de ser necesarios.

Modo aplicativo: reduce primero todos los argumentos. Se hace en otros lenguajes
como c.

\subsection{Esquemas de recursion}

Formas de recursion comunes que uno puede aprovechar usando funciones de alto
orden.

\subsubsection{Map}

\begin{minted}[]{haskell}
-- tal que dobleL xs es la lista que contiene el doble de cada elemento en xs
dobleL :: [Float] -> [Float]
dobleL [] = []
dobleL (x:xs) = 2*x : dobleL xs

-- tal que la lista esParL xs indica si el correspondiente elemento en xs es par
-- o no
esParL :: [Int] -> [Bool] 
esParL [] = []
esParL (x:xs) = (even x) : esParL xs

-- tal que longL xs es la lista que contiene las longitudes de las listas en xs
longL :: [[a]] -> [Int]
longL [] = []
longL (x:xs) = (length x) : longL xs

-- esquema recursivo de map:
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map g (x:xs) = g x : map g xs

-- Con eso, se pueden reescribir como
dobleL = map ((*) 2)
esParL = map even
longL = map length
\end{minted}

\subsubsection{Filter}

\begin{minted}{haskell}
-- tal que negativos xs contiene los elementos negativos de xs
negativos :: [Float] -> [Float]
negativos [] = []
negativos (x:xs)
    | x < 0 = x : (negativos xs)
    | otherwise = negativos xs

-- tal que la lista noVacias xs contiene las listas no vacias de xs
noVacias :: [[a]] -> [[a]]
noVacias [] = []
noVacias (l:ls)
    | (length l > 0) = l : (noVacias ls)
    | otherwise = noVacias ls

-- esquema recursivo:
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) = if (p x) then x : (filter p xs)
                  else (filter p xs)

-- luego quedan
negativos = filter (\x -> x < 0)
noVacias = filter (\l -> length l != 0)
noVacias = filter ((> 0) . length) -- f o g = f(g(x))

\end{minted}

\subsection{Transparencia referencial}

El valor de una expresion en funcional depende solo de sus subexpresiones. Esto
a diferencia de imperativo que depende del estado.

Si dos expresiones son iguales, denotan el mismo valor bajo el mismo contexto.

\subsection{Folds}

\subsubsection{\texttt{foldr}}

\begin{minted}[]{haskell}
-- Funciones sobre listas

-- sumaL: suma de todos los valores de una lista de enteros
sumaL :: [Int] -> Int
sumaL [] = 0
sumaL (x:xs) = x + (sumaL xs)

-- concat: la concatenación de todos los elementos de una lista de listas
concat :: [[a]] -> [a]
concat [] = []
concat (l:ls) = l ++ (concat ls)

-- reverso: el reverso de una lista
reverso :: [a] -> [a]
reverso [] = []
reverso (x:xs) = (reverso xs) ++ [x]

-- Esquema de recursión
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

-- Luego, con esto
sumaL = foldr (+) 0
concat = foldr (++) []
reverso = foldr (\x rec -> rec ++ [x]) []
reverso = foldr ( (flip (++)) . (:[])) []

-- Hasta podemos definir map y filter. El fold es más general que el map y
-- filter
map f = foldr (\x rec -> f x : rec) []
map f = foldr ((:) . f) []

-- (:) . f :: a -> [b] -> [b]
-- ((:) . f) x  = (f x) :

filter p = foldr (\x rec -> if p x then x : rec else rec) []

-- Longitud y suma con una sola pasada sobre la lista
sumaLong :: [Int] -> (Int, Int)
sumaLong = foldr (\x (rl, rn) -> (rl + 1, rn + x)) (0, 0)
\end{minted}

\subsubsection{\texttt{recr}}

\begin{minted}[]{haskell}
-- dropWhile
dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p (x:xs) = if p x then dropWhile p xs else x:xs

-- ejemplo
dropWhile even [2, 4, 1, 6] = [1, 6]

-- drop while cuando se termina de cumplir devuelvo todo lo que viene "a la
-- derecha", pero cuando hago fold, lo que está a la derecha ya pasó por la
-- recursión.

dw p = first $ (foldr (\x (r1, r2)
    -> (if p x then r1 else x: r2, x: r2 ) ), ([], []))

-- Otro esquema más poderoso
g :: [a] -> b
g [] = z
g (x:xs) = f x xs (g xs)

recr :: b -> (a -> [a] -> b -> b) -> [a] -> b
recr z _ [] = z
recr z f (x:xs) = f x xs (rec z f xs)

dropWhile p = recr [] (\x xs rec -> if p x then rec else x:xs)

-- foldr en terminos de recr?
foldr f z = recr z (\x xs rec -> f x rec)

-- recr en términos de foldr?
recr z f = first $
    foldr
        (\x (rs1, rs2) -> (f x rs2 rs1, x:rs2))
        (z, [])
\end{minted}

\subsubsection{\texttt{foldl}}

\begin{minted}[]{haskell}
    foldl :: (b -> a -> b) -> b -> [a] -> b
    foldl _ z [] = z
    foldl f z (x:xs) = foldl f (f z x) xs
\end{minted}

foldr = fold a la derecha, y foldl = fold a la izquierda

\begin{minted}[]{haskell}
reverse = foldl (\c x -> x:c) []
reverse = foldl (flip (:)) []
\end{minted}

Y uno en términos del otro? \textit{Me falta repasar esto porque estaba matado,
min 2:35:10 del video}

\subsubsection{Fold sobre estructuras algebrácias}

\begin{minted}[]{haskell}
-- Arbol binario
data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)

-- Por ej.

Nodo 1 (Hoja 2) (Hoja 3)

-- Es
--
--   1
--  / \
-- 2   3

-- Y sobre ella podemos querer operaciones, como map

mapA :: (a -> b) -> Arbol a -> Arbol b
mapA f (Hoja x) = Hoja f x
mapA f (Nodo x izq der) = Nodo (f x) (mapA f izq) (mapA f der)

-- Y también podemos hacer un fold

foldA :: (a -> b) -> (a -> b -> b -> b) -> Arbol a -> b
foldA f g (Hoja x) = f x
foldA f g (Nodo x izq der) = g x (foldA f g izq) (foldA f g der)

sumaA = foldA id (\x rizq rder -> x + rizq + rder)
contarHojas = foldA 1 (\x rizq rder -> rizq + rder)

-- Arboles generales
data AG = NodoAG a [AG a]

mapAG :: (a -> b) -> AG a -> AG b
mapAG f (Nodo AG a as) -> NodoAG (f a) (map (mapAG f) as)

foldAG :: (a -> [b] -> b) -> AG a -> b
foldAG f (NodoAG a as) = f a (map (foldAG f) as)
\end{minted}

\textit{Aplicar un fold con un constructor es la identidad}.

\section{Cálculo Lambda Tipado}

Es el formalismo que está detrás de la programación funcional. Es un modelo de
cómputo basado en \textbf{funciones}, introducido por Alonzo Church en 1934. Es
computacionalmente completo (turing completo) y nosotros vamos a estudiar la
variante tipada (Church, 1941.)

La máquina de turing es más de estado, y este con reducción de expresiones.

\begin{definition}[Tipos]
    Las \textbf{expresiones de tipos} (o tipos) de $\lambdab$ (lambda cálculo b
    de booleano) son

    \[
        \sigma, \tau ::= Bool \mid \tfunc{\sigma}{\tau}
    \]

    Informalmente, 
    
    \begin{itemize}
        \item \textit{Bool} es el tipo de los booleanos, y
        \item $\tfunc{\sigma}{\tau}$ es el tipo de las funciones de tipo $\sigma$ en tipo $\tau$.
    \end{itemize}

    \begin{example*}
        Ejemplos:
        \begin{itemize}
            \item $\tfunc{Bool}{Bool}$
            \item $\tfunc{\tfunc{Bool}{Bool}}{Bool}$
        \end{itemize}
    \end{example*}
\end{definition}

\begin{definition}[Terminos]
    Los términos se escriben con las siguientes reglas de sintaxis.

    Sea $\chi$  un conjunto infinito enumerable de variables, y $x \in \chi$.
    Los \textbf{términos} de $\lambdab$ están dados por,

    \begin{align*}
        M, N, P, Q ::&= x \\
            &\mid \quad true \\
            &\mid \quad false \\
            &\mid \quad \ifte{M}{P}{Q} \\
            &\mid \quad \abs{x}{\sigma}{M} \\
            &\mid \quad \app{M}{N} \\
    \end{align*}

    \begin{example*} Ejemplos:
        \begin{itemize}
            \item $\abs{x}{Bool}{x}$ \cmark
            \item $\abs{x}{Bool}{\ifte{x}{false}{true}}$ \cmark
            \item
            $\abs{f}{\tfunc{Bool}{\tfunc{Bool}{Bool}}}{\abs{x}{Bool}{\app{f}{x}}}$
            \cmark
            \item $(\abs{f}{\tfunc{Bool}{Bool}}{\app{f}{true}})
            (\abs{y}{Bool}{y})$ \cmark
            \item $\app{true}{(\abs{x}{Bool}{x})}$ \cmark
            \item $\app{x}{y}$ \cmark
            \item $\lambda x : true$ \xmark
        \end{itemize}
    \end{example*}
\end{definition}

\subsection{Sistema de tipado}

Es un sistema formal de deducción o derivación que utiliza axiomas y reglas de
inferencia para caracterizar un subconjunto de los términos llamados
\textbf{tipados}. Nos permite quedarnos con algunos y rechazar otros términos en
base a lo que consideremos correcto.

Definimos una \textbf{relación de tipado} en base a reglas de inferencia.
\begin{itemize}
    \item Los \textbf{axiomas de tipado} establecen que ciertos \textbf{juicios
    de tipado} son derivables.
    \item Las \textbf{reglas de tipado} establecen que ciertos \textbf{juicios
    de tipado} son derivables siempre y cuando ceiertos otros lo sean.  
\end{itemize}

\begin{definition}[Variables libres]
Una variable puede ocurrir \textbf{libre} o ligada en un término. Decimos que
$x$ ocurre \textbf{libre} si no se encuentra bajo el alcance de una ocurrencia
de $\lambda x$. Caso contrario ocurre ligada.

Ejemplos:

\begin{itemize}
    \item $\abs
        {x}{Bool}
        {\ifte{\ligada{x}}{true}{false}}$
    \item $\abs
        {x}
        {Bool}
        {\abs{y}{Bool}{\ifte{true}{\ligada{x}}{\ligada{y}}}}$
    \item $\abs{x}{Bool}{\ifte{\ligada{x}}{true}{\libre{y}}}$
    \item $\app{(\abs{x}{Bool}{\ifte{\ligada{x}}{true}{false}})}{\libre{x}}$
\end{itemize}

La definición formal es a partir de cada término del lambda cálculo por pattern
matching. FV = Free Variable

\begin{align*}
    FV(x) &\eqdef \{ x \} \\
    FV(true) = FV(false) &\eqdef \emptyset \\
    FV(\ifte{M}{P}{Q}) &\eqdef FV(M) \cup FV(P) \cup FV(Q) \\
    FV(\app{M}{N}) &\eqdef FV(M) \cup FV(N) \\
    FV(\abs{x}{\sigma}{M}) &\eqdef FV(M) \setminus \{ x \}
\end{align*}
\end{definition}

\begin{definition}[Juicio de tipado]
    Un \textbf{juicio de tipado} es una expresión de la forma
    $\tipa{\Gamma}{M}{\sigma}$, que se lee \textit{``El término M tiene el
    tipo $\sigma$ asumiendo el contexto de tipado $\Gamma$''}.

    Un \textbf{contexto de tipado} es un conjunto de pares $x_i : \sigma_i$,
    notado $\{ x_1 : \sigma_1, \dots, x_n : \sigma_n \}$ donde los $x_i$ son
    distintos. Usamos las letras $\Gamma, \Delta, \dots$ para contextos de
    tipado.

    A las variables se les anota un tipo. Uno pone las asunciones que tiene
    sobre el tipo de algunas variables, como $x : Bool$.
\end{definition}

\begin{definition}[Axiomas de tipado de $\lambdab$]

Son guiadas por sintaxis al igual que las variables libres

\[
    \deriv{T-True}{}{\Gtipa{true}{Bool}} \quad
    \deriv{T-False}{}{\Gtipa{false}{Bool}}
\]

(para cualquier contexto de tipado $\Gamma$)

\[
    \deriv
        {T-Var}
        {\tienetipo{x}{\sigma}{\Gamma}}
        {\Gtipa{x}{\sigma}}
\]

\[
    \deriv
        {T-If}
        {
            \Gtipa{M}{Bool} \quad
            \Gtipa{P}{\sigma} \quad
            \Gtipa{Q}{\sigma}
        }
        {\Gtipa{\ifte{M}{P}{Q}}{\sigma}}
\]

P y Q tienen que tener el mismo tipo porque queremos que la expresion siempre
tipe a lo mismo.

\[
    \deriv
        {T-Abs}
        {\tipa{\Gamma, x : \sigma}{M}{\tau}}
        {\Gtipa{\abs{x}{\sigma}{M}}{\tfunc{\sigma}{\tau}}}
    \quad
    \deriv
        {T-App}
        {
            \Gtipa{M}{\tfunc{\sigma}{\tau}} \quad
            \Gtipa{N}{\sigma}
        }
        {\Gtipa{\app{M}{N}}{\tau}}
\]
\end{definition}

Si $\Gtipa{M}{\sigma}$ puede derivarse usando los axiomas y reglas de tipado,
decimos que es \textbf{derivable}, y decimos que $M$ es \textbf{tipable} si el
juicio de tipado $\Gtipa{M}{\sigma}$ puede derivarse para algún $\Gamma$ y
$\sigma$.

Ejemplos:

\begin{itemize}
    \item $\abs{x}{Bool}{x} : \textcolor{blue}{\tfunc{Bool}{Bool}}$
    
    \[
    \deriv
        {T-Abs}
        {
            \deriv
                {T-Var}
                {\derivok{x : Bool \in \Gamma'}}
                {
                    \tipa{\Gamma' = \Gamma \cap \{x : Bool\}}{x}{Bool}
                }
        }
        {\Gtipa{\abs{x}{Bool}{x}}{\textcolor{blue}{\tfunc{Bool}{Bool}}}}
    \]

    \item $\abs{x}{Bool}{\ifte{x}{false}{true}}$
    \item $\abs{f}{\tfunc{Bool}{\tfunc{Bool}{Bool}}}{\abs{x}{Bool}{\app{f}{x}}}$
    \item $(\abs{f}{\tfunc{Bool}{Bool}} \app{f}{true})(\abs{y}{Bool}{y})$
    \item $\app{true}{(\abs{x}{Bool}{x})}$. No va a tipar nunca, porque $true :
    Bool$ y para $T-App$ necesitamos que sea $\tfunc{\sigma}{\tau}$.
    \item $\app{x}{y}$. Para usar T-App, x por sintaxis solo aplica a T-Var. La
    única forma de que pueda aplicar x con y, x tiene que ser tipo flecha. Pero
    es una variable, entonces solo funcionaría si tenemos como asunción de tipo
    de x como función en $\Gamma$. Sin eso no se puede tipar.
\end{itemize}

\subsection{Resultados básicos}

\textit{Se pueden probar por inducción en la longitud de las reglas}

\begin{proposition}[Unicidad de tipos]
    Si $\Gtipa{M}{\sigma}$ y $\Gtipa{M}{\tau}$ son derivables, entonces $\sigma
    = \tau$.

    \textit{Si una expresión tiene un tipo, ese tipo es único.}
\end{proposition}

\begin{proposition}[Weakening + Strengthening]
    Si $\Gtipa{M}{\sigma}$ es derivable y $\Gamma \cap \Gamma'$ contiene a todas
    las variables libres de $M$, entonces $\tipa{\Gamma'}{M}{\sigma}$.

    \textit{Puedo agrandar o achicar el contexto de tipo siempre y cuando contenga las mismas variables libres.}
\end{proposition}

\subsection{Semántica}

Habiendo definido la sintaxis de $\lambdab$, nos interesa formular como se
\textbf{evalúan} o \textbf{ejecutan} los términos. Hay varias maneras de definir
\textbf{rigurosamente} la semántica de un lenguaje de programación, nosotros
vamos a definir una \textbf{semántica operacional}.

\begin{itemize}
    \item Denotacional. Darle una \textit{denotación} a cada símbolo del
    lenguaje, qué denota matemáticamente. Y uno define la semántica en términos
    de como las funciones van denotando cosas, con recursión o puntos fijos.
    \item Axiomática. Cuando cursamos algo1, definimos pre y pos condiciones.
    Predicaque definen el significado de una operación. Las triplas de hoare y
    esas cosas.
    \item \textbf{Operacional} consiste en
    \begin{itemize}
        \item interpretar a los \textbf{términos como estados} de una máquina
        abstracta, y
        \item definir una \textbf{función de transición} que indica dado un
        estado cuál es el siguiente. 
    \end{itemize}
\end{itemize}

El \textbf{significado} de un término $M$ es el estado final que alcanza la
máquina al comenzar con $M$ como estado inicial. Hay dos formas de definir
semántica operacional,

\begin{itemize}
    \item \textbf{Small-step}: la función de transición describe un paso de
    computación. Esta vamos a hacer nosotros.
    \item \textbf{Big-step} (o \textbf{Natural Semantics}): la función de
    transición, en un paso, evalúa el término a su resultado.
\end{itemize}

\begin{definition}[Juicios]
    La formulación se hace a través de \textbf{juicios de evaluación}
    $\reduce{M}{N}$, que se leen \textit{``el término M reduce, en un paso, al
    término N''}.

    El significado de un juicio de evaluación se establece a través de:

    \begin{itemize}
        \item \textbf{Axiomas de evaluación}, que establecen que ciertos juicios
        de evaluación son derivables.
        \item \textbf{Reglas de evaluación}, que establecen que ciertos juicios
        de evaluación son derivables siempre y cuando ciertos otros lo sean
    \end{itemize}

    \textit{(análogo a axiomas y reglas de tipado)}
\end{definition}


\subsubsection{Semántica operacional small-step de $\lambdab$}
Además de introducir la función de transición es necesario introducir también
los \textbf{valores}, los posibles resultados de evaluación de términos
bien-tipados (derivables) y cerrados (sin variables libres).

Valores

\[
    V ::= true \mid false
\]

todo término bien-tipado y cerrado de tipo Bool evalúa, en cero
(directamente) o más pasos, a true o false. Se puede demostrar formalmente.

Juicio de evaluación en un paso:

\[
    \deriv{E-IfTrue}
        {}
        {
            \reduce
                {\ifte{true}{M_2}{M_3}}
                {M_2}
        }
\]
\vspace{0.5cm}
\[
    \deriv{E-IfFalse}
        {}
        {
            \reduce
                {\ifte{false}{M_2}{M_3}}
                {M_3}
        }
\]
\vspace{0.5cm}
\[
    \deriv{E-If}
        {\reduce{M_1}{M_1'}}
        {
            \reduce
                {\ifte{M_1}{M_2}{M_3}}
                {\ifte{M_1'}{M_2}{M_3}}
        }
\]

Ejemplo de derivación

\begin{align*}
    &\ifte
        {(\ifte{false}{false}{true})}
        {false}
        {true}\\
    &\reducesTo{E-If, E-IfFalse}
        \ifte{true}{false}{true}\\
    &\reducesTo{E-IfTrue} false
\end{align*}

\begin{observation}
    No existe M tal que $\reduce{true}{M}$ o $\reduce{false}{M}$. No los puedo reducir más.
\end{observation}

\begin{observation}
    La estrategia de evaluación corresponde con el orden habitual de los
    lenguajes de programación.

    \begin{enumerate}
        \item Primero evaluar la guarda del condicional.
        \item Una vez que la guarda sea un valor, seguir con la expresión del
        then o del else, según corresponda.
    \end{enumerate}

    Por ejemplo,
    \begin{align*}
        &\ifte
            {true}
            {(\ifte{false}{false}{true})}
            {true}\\
        \textcolor{red}{\not\to} &\ifte{true}{true}{true}
    \end{align*}

    y,

    \begin{align*}
        &\ifte
            {true}
            {(\ifte{false}{false}{true})}
            {true}\\
        \textcolor{teal}{\to} &\ifte{false}{false}{true}
    \end{align*}
\end{observation}

\begin{lemma}[Determinismo del juicio de evaluación en un paso]
    Si $\reduce{M}{M'}$ y $\reduce{M}{M''}$, entonces $M' = M''$.
\end{lemma}

\begin{definition}[Forma normal]
    Una forma normal es un término que no puede reducirse o evaluarse más. i.e
    $M$ tal que no existe $N$, $\reduce{M}{N}$.
\end{definition}
\begin{lemma}
    Todo valor está en forma normal.

    \textit{No vale el recíproco en $\lambdab$, puedo tener cosas que están en forma normal pero que no sean valores, como términos que no estén bien tipados o que no sean cerrados. Ejemplos:}
    
    \begin{itemize}
        \item $\ifte{x}{true}{false}$: No tengo forma de reducir el x.
        \item $x$. No tengo forma de reducirla pero no es ni true ni false
        \item $\app{true}{false}$.
    \end{itemize}
    
    \textit{Pero si vale en el cálculo de las expresiones booleanas cerradas.}
\end{lemma}

\subsubsection{Evaluación en muchos pasos}

El juicio de \textbf{evaluación en muchos pasos} $\reduceManyTo$ es la
clausura reflexiva, transitiva de $\to$. Es decir, la menor relación tal que

\begin{enumerate}
    \item Si $\reduce{M}{M'}$, entonces $\reduceMany{M}{M'}$
    \item $\reduceMany{M}{M}$ para todo $M$.
    \item Si $\reduceMany{M}{M'}$ y $\reduceMany{M'}{M''}$, entonces $\reduceMany{M}{M''}$.
\end{enumerate}

\textit{captura la evolución en 0 y 1 pasos y la transitiva.}

\begin{example*}
    \[
    \reduceMany
        {\ifte{true}{(\ifte{false}{false}{true})}{true}}
        {true}
    \]
\end{example*}

\begin{proposition}[Unicidad de formas normales]
    Si $\reduceMany{M}{U}$ y $\reduceMany{M}{V}$ con U, V formas normales,
    entonces $U = V$

    \textit{aplicamos las reglas y llegamos a dos terminos entonces tienen que
    ser iguales.}
\end{proposition}

\begin{proposition}[Terminación]
    Para todo $M$ existe una forma normal $N$ tal que $\reduceMany{M}{N}$.

    \textit{no me quedo ciclando, en una cantidad finita de pasos llego a una forma normal.}
\end{proposition}

\subsubsection{Extendiendo semántica operacional con funciones}

Valores

\[
    V ::= true \mid false \mid \textcolor{blue}{\abs{x}{\sigma}{M}}
\]

vamos a introducir una noción de evaluación tal que valgan los lemas previos y
también el siguiente resultado

\begin{theorem}
    Todo término bien tipado y cerrado de tipo
    \begin{itemize}
        \item $Bool$ evalúa, en \textbf{cero o más} pasos a true o false.
        \item $\tfunc{\sigma}{\tau}$ en \textbf{cero o más pasos} a
        $\abs{x}{\sigma}{M}$, para alguna variable x y término M.
    \end{itemize}
\end{theorem}

Juicios de evaluación en un paso (Además de E-IfTrue, E-IfFalse y E-If):

\[
    \deriv{E-App1 / $\mu$}
        {\reduce{M_1}{M_1'}}
        {
            \reduce
                {\app{M_1}{M_2}}
                {\app{M_1'}{M_2}}
        }
    \quad\quad
    \text{\textit{primero reducís la función}}
\]

\[
    \deriv{E-App2 / $\nu$}
        {\reduce{M_2}{M_2'}}
        {
            \reduce
                {
                    \app
                        {\textcolor{red}{(\abs{x}{\sigma}{M})}}
                        {M_2}
                }
                {
                    \app
                        {\textcolor{red}{(\abs{x}{\sigma}{M})}}
                        {M_2'}
                }
        }
    \quad\quad
    \text{\textit{luego reducís el "argumento"}}
\]

\[
    \deriv{E-AppAbs / $\beta$}
        {}
        {
            \reduce
                {(\abs{x}{\sigma}{M}) \textcolor{red}{V}}
                {\sustOne{M}{x}{\textcolor{red}{V}}}
        }
    \quad\quad
    \text{\textit{primero reducís la función}}
\]

\subsubsection{Sustitución}

La operación,

\[
    \sustOne{M}{x}{N}
\]

quiere decir \textit{"Sustituir todas las ocurrencias \textbf{libres} de x en el
término M por el término N}. Es una operación importante que se usa para darle
semántica a la aplicación de funciones. Es sencilla de definir pero requiere
cuidado en el tratamiento de los ligadores de variables ($\lambda x$).

Se define por sintaxis,

\begin{align*}
    \sustOne{x}{x}{N} &\eqdef N \\
    \sustOne{a}{x}{N} 
        &\eqdef
        a \ \text{ si } a\in \{true,\ false \} \cup \chi \setminus \{x \} \\
    \sustOne{(\ifte{M}{P}{Q})}{x}{N}
        &\eqdef
        \ifte
            {\sustOne{M}{x}{N}}
            {\sustOne{P}{x}{N}}
            {\sustOne{N}{x}{N}} \\
    \sustOne{(\app{M_1}{M_2})}{x}{N}
        &\eqdef
        \app{\sustOne{M_1}{x}{N}}{\sustOne{M_2}{x}{N}}\\
    \sustOne{(\abs{y}{\sigma}{M})}{x}{N}
        &\eqdef
        \abs{y}{\sigma}{\sustOne{M}{x}{N}} \ x \neq y, y \notin FV(N)
\end{align*}

\begin{enumerate}
    \item NB: La condición $x\neq y, y \notin FV(N)$ \textbf{siempre} puede
    cumplirse renombrando apropiadamente.
    \item Técnicamente, la sustitución está definida sobre \textbf{clases de
    $\alpha$-equivalencia de términos}.
\end{enumerate}

\subsubsection{$alpha$-equivalencia}

Si en la siguiente expresión queremos sustituir la variable $x$ por el término
$z$,

\[
    \sustOne{(\abs{z}{\sigma}{x})}{x}{z} = \abs{z}{\sigma}{z}
\]

y lo hacemos de forma \textit{naive}, convertimos una función constante en la
identidad. El problema es que $\lambda z : \sigma$ capturó la ocurrencia libre
de $z$. Pero los nombres de las variables ligadas no son relevantes, la ecuación
de arriba debería ser lo mismo que

\[
    \sustOne{(\abs{w}{\sigma}{x})}{x}{z} = \abs{w}{\sigma}{z}
\]

para definir la sustitución sobre aplicaciones
$\sustOne{(\abs{y}{\sigma}{M})}{x}{N}$ vamos a asumir que la variable ligada $y$
se renombró de forma tal que no ocurre libre en N.

\begin{definition}[$\alpha$-equivalencia]
    Dos términos $M$ y $N$ que difieren solamente en el nombre de sus variables
    ligadas se dicen $\alpha$-equivalentes. Es una relación de equivalencia.
    
    \begin{example*} Ejemplos:
        \begin{itemize}
            \item $\abs{x}{Bool}{x} \aeq \abs{y}{Bool}{y}$
            \item $\abs{x}{Bool}{y} \aeq \abs{z}{Bool}{y}$
            \item $\abs{x}{Bool}{y} \naeq \abs{x}{Bool}{z}$
            \item $\abs{x}{Bool}{\abs{x}{Bool}{x}} \naeq \abs{y}{Bool}{\abs{x}{Bool}{y}}$
        \end{itemize}        
    \end{example*}
\end{definition}

\textit{La idea detrás es agrupar expresiones que sean semánticamente equivalentes.}

\subsubsection{Estado de error}

Un \textbf{estado de error} es un término que no es un valor pero en el que la
evaluación está trabada. (Un término en forma normal que no es un valor).
Representa un estado en el cual el sistema de runtime en una implementación real
generaría una excepción. Ejemplos:

\begin{itemize}
    \item $\ifte{x}{M}{N}$ (no es cerrado)
    \item $\app{true}{M}$ (no es tipable)
\end{itemize}

\subsubsection{Objetivo de un sistema de tipos}

El objetivo de un sistema de tipos es garantizar la \textbf{ausencia} de estados
de error.

\begin{definition}
    Decimos que un término \textbf{termina} o que es \textbf{fuertemente
normalizante} si no hay cadenas de reduccioens infinitas a partir de él.
\end{definition}

\begin{theorem}
    Todo término bien tipado termina. Si un término cerrado está bien tipado,
    entonces evalúa a un valor.
\end{theorem}

Esto es lo que nos gustaría que cumpla nuestro lenguaje.

\subsubsection{Corrección}

Decimos que \textbf{Corrección = Progreso + Preservación}.

\begin{definition}[Progreso]
    Si $M$ es cerrado y bien tipado, entonces
    \begin{enumerate}
        \item $M$ es un valor, o bien
        \item existe $M'$ tal que $\reduce{M}{M'}$
    \end{enumerate}

    \textit{La evaluación no puede trabarse para términos cerrados, bien tipados que no son valores.}
\end{definition}

\begin{definition}[Preservación]
    Si $\Gtipa{M}{\sigma}$ y $\reduce{M}{N}$, entonces $\Gtipa{N}{\sigma}$.

    \textit{La evaluación preserva tipos.}
\end{definition}
\end{document}

